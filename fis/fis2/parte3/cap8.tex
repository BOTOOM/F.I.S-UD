\chapterimage{conclusiones.jpg} % Table of contents heading image
\chapter{Conclusiones}

\section{Conclusiones}
Después de realizar el recorrido a lo largo del estudio de los procesos y metodologías de software, y además, mirar las estructuras que definían el diseño de software para luego implementarlo en el proyecto del curso, fue posible realizar las siguientes conclusiones:
\begin{itemize}
	\item El desarrollo de software se basa esencialmente en la definición y posterior ejecución de tres grandes aspectos: la especificación, el desarrollo y el mantenimiento. Estos grandes pilares representan la base a la hora de emprender cualquier proyecto de software y se encuentran en cualquiera de los posibles caminos que especifique una metodología, ya sea de forma explícita o implícitamente.  
	
	\item A lo largo de los años se han venido construyendo propuestas sobre las cuales trabajar para poder fijar el rumbo de un proyecto, todas siempre sustentadas en la experiencia y que tienen en cuenta situaciones específicas. Para el proyecto particular de EcnonomApp, el hecho de haber escogido la metodología RUP fue precisamente debido a que sus protocolos se ajustaban a las necesidades de la construcción de la aplicación, es decir, la capacidad de no tener estados rígidos y dependientes sino una serie de procesos adaptables, prioridades balanceadas, adquisición de valor de forma iterativa, entre otras, se ajustaban a las necesidades del equipo.
	
	\item Una vez establecida la forma en la que se realizan las cosas llega la hora de trabajarlas. Es allí donde la definición de requerimientos adquiere una importancia natural, porque fija el punto de partida, señala lo que el sistema final debe realizar, establece una característica de rendimiento con la cual evaluar el resultado, y desde la cual establecer las correcciones necesarias llegado el caso que no se logre lo esperado.
	
	\item El lenguaje UML proporciona una serie de herramientas estandarizadas que se ofrecen con el fin de realizar una explicación asertiva del sistema al cual hace referencia, por lo que brinda la capacidad de que cualquier persona, incluso que no se halla encontrado en la construcción de un proyecto, lo entienda e interprete.
	
	\item El objetivo del lenguaje UML es la respuesta al ¿cómo? del sistema, una vez expuesto el ¿qué? en el establecimiento de los requerimientos y los casos de uso. Para empezar a describir el ¿cómo? se empieza desde la parte de la identificación de objetos y su comunicación, esto no es de extrañar dado que UMl nace en el marco del paradigma de la programación orientada a objetos.
	
	\item Después de las posterior generalización de los objetos en clases, surgen conceptos. Dentro de la especificación de los pilares de la orientación a objetos se habla de que los programas deben ser abiertos para la extensión y cerrados para la modificación, es allí donde nacen dos conceptos completamente nuevos, y son las cajas blancas y las cajas negras, donde las primeras son abstracciones encaminadas a un acoplamiento máximo y una seguridad mínima, y las segundas ofrecen seguridad máxima y acoplamiento mínimo.
	
	\item En el diseño de los programas se mide el nivel de confianza de una estructura pensada en función del número de interfaces y clases abstractas que contenga, por lo que si se visualizan exceso de clases concretas, es necesario preocuparse por la forma como se modeló el problema.
	
	\item Muchas veces un elemento en el contexto del diseño de sotware sufre cambios en su estado, los cuales afectan de forma directa el comportamiento de éste y su uso en determinadas situaciones. Es por ello que se utiliza el diagrama de máquina de estados, para visualizar la interacción entre diferentes estados a partir de disparos y transiciones.
	
	\item En un sistema es importante poder visualizar el flujo de algún elemento y la señalización del paso de una actividad a otra, es decir los procesos en alto nivel, es por ello que se utiliza el diagrama de actividades, y es allí donde recae su importancia.
	
	\item Llegando al final del diseño uno de los temas que va aumentando su nivel de complejidad es el de la agrupación y la organización de modulos, empezando por el concepto de sistemas dónde se analiza una característica principal y un grado alto de afinidad modular para segmentar y clasificar las clases y guardarlas en paquetes. Después, pasando por el concepto de componentes en los cuales se busca cual es el trabajo de determinados sistemas y se procede a segmentarlos en unidades aún mas diferenciables, y que además tengan capacidades de ser coherentes en sí mismos, es decir, no depender de ninguna otra instancia para poder saber cual es su función. Finalmente, se llega al concepto de nodo, en el cual, desde un punto de vista más alejado del software y mas general, se corresponde a poner determinados sistemas en deterinados nodos dependiendo de cual es el recurso que éstos necesitan.
	
	\item Todos estos aspectos se utilizan para poder hacer frente de una forma especializada a la dificil tarea de la construcción de soluciones, pero gracias a las buenas prácticas de diseño, se simplifica de forma que sea un aspecto manejable y posible, aterrizando todos los experimentos reales en una cuestión práctica, concreta y tangible.
\end{itemize}